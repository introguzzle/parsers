package ru.introguzzle.parsers.common.io.watch;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.WatchEvent;
import java.nio.file.WatchService;
import java.nio.file.WatchKey;
import java.nio.file.StandardWatchEventKinds;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiFunction;
import java.util.function.Consumer;

import static ru.introguzzle.parsers.common.io.watch.Report.Type.CREATE;
import static ru.introguzzle.parsers.common.io.watch.Report.Type.MODIFY;
import static ru.introguzzle.parsers.common.io.watch.Report.Type.DELETE;

/**
 * An abstract class that monitors a specific file for changes such as creation, modification, and deletion.
 * <p>
 * The `FileWatcher` utilizes Java NIO's {@link WatchService} to listen for file system events.
 * Subclasses must implement methods to handle events, map events to reports, handle closure, and manage errors.
 *
 * @param <R> The type of {@link Report} generated by the watcher.
 */
public abstract class FileWatcher<R extends Report> extends Thread {
    private final AtomicBoolean signal = new AtomicBoolean(false);
    private final AtomicBoolean closed = new AtomicBoolean(false);

    private final Path path;
    private final @Nullable Runnable onStart;

    /**
     * Constructs a new `FileWatcher` for the specified file path with a default thread name.
     *
     * @param path The path of the file to watch.
     */
    public FileWatcher(@NotNull Path path) {
        this(path, "FileWatcher on file " + path);
    }

    /**
     * Constructs a new `FileWatcher` for the specified file path with a custom thread name.
     *
     * @param path The path of the file to watch.
     * @param name The name of the watcher thread.
     */
    public FileWatcher(@NotNull Path path, @NotNull String name) {
        this(path, name, null);
    }

    /**
     * Constructs a new `FileWatcher` for the specified file path with a custom thread name and an optional startup action.
     *
     * @param path    The path of the file to watch.
     * @param name    The name of the watcher thread.
     * @param onStart A {@link Runnable} to execute when the watcher starts, or {@code null} if none.
     */
    public FileWatcher(@NotNull Path path,
                       @NotNull String name,
                       @Nullable Runnable onStart) {
        this.path = path;
        setPriority(Thread.MIN_PRIORITY);
        setDaemon(true);
        setName(name);
        this.onStart = onStart;
    }

    /**
     * Checks whether the watcher has been signaled to stop.
     *
     * @return {@code true} if the watcher should stop; {@code false} otherwise.
     */
    public final boolean isStopped() {
        return signal.get();
    }

    /**
     * Signals the watcher to stop and invokes the close handler if not already closed.
     * Interrupts the thread to wake it if it's blocked.
     */
    public final void stopThread() {
        if (closed.compareAndSet(false, true)) {
            onCloseHandler().run();
        }

        signal.set(true);
        interrupt();
    }

    /**
     * Invokes the close handler if not already closed.
     * Ensures that the close handler is called only once.
     */
    public final void onClose() {
        if (closed.compareAndSet(false, true)) {
            onCloseHandler().run();
        }
    }

    /**
     * Retrieves the path of the file being watched.
     *
     * @return The {@link Path} of the file.
     */
    public final Path getPath() {
        return path;
    }

    /**
     * Returns the set of file event types that the watcher is monitoring.
     * By default, it watches for create, modify, and delete events.
     *
     * @return A set of {@link Report.Type} representing the events being watched.
     */
    public Set<Report.Type> getReportTypes() {
        return Set.of(CREATE, MODIFY, DELETE);
    }

    /**
     * Maps a file path and event type to a {@link Report} object.
     * Subclasses must implement this method to create appropriate reports for events.
     *
     * @return A {@link BiFunction} that takes a {@link Path} and {@link Report.Type}, and returns a {@link Report}.
     */
    public abstract @NotNull BiFunction<Path, Report.Type, ? extends R> mapper();

    /**
     * Provides a handler to process events.
     * Subclasses must implement this method to handle the reports generated by the mapper.
     *
     * @return A {@link Consumer} that accepts reports of type {@code R}.
     */
    public abstract @NotNull Consumer<? super R> eventHandler();

    /**
     * Provides a handler to execute when the watcher is closed.
     * This method should return a {@link Runnable} that contains the logic to execute upon closure.
     *
     * @return A {@link Runnable} to be executed when the watcher is closed.
     */
    public abstract @NotNull Runnable onCloseHandler();

    /**
     * Provides a handler for {@link IOException}s that may occur during watching.
     * Subclasses must implement this method to handle I/O errors appropriately.
     *
     * @return A {@link Consumer} that accepts {@link IOException}s.
     */
    public abstract @NotNull Consumer<? super IOException> onError();

    /**
     * Starts the file watcher thread.
     * <p>
     * This method initializes the {@link WatchService}, registers the file path for events,
     * and enters a loop to process events until the watcher is stopped.
     * It handles creation, modification, and deletion events for the specified file.
     */
    @Override
    public void run() {
        if (onStart != null) {
            onStart.run();
        }

        try {
            WatchService watcher = FileSystems.getDefault().newWatchService();
            try {
                Path directory = path.getParent();
                if (directory == null) {
                    throw new IOException("Invalid path: " + path);
                }

                directory.register(watcher, getReportTypes()
                        .stream()
                        .map(Report.Type::getKind)
                        .toList()
                        .toArray(new WatchEvent.Kind<?>[0])
                );

                while (!isStopped()) {
                    WatchKey key;
                    try {
                        key = watcher.take();
                    } catch (InterruptedException e) {
                        return;
                    }

                    if (key == null) {
                        Thread.yield();
                        continue;
                    }

                    List<WatchEvent<?>> polled = key.pollEvents();
                    for (WatchEvent<?> event : polled) {
                        WatchEvent.Kind<?> kind = event.kind();
                        Object context = event.context();

                        if (kind == StandardWatchEventKinds.OVERFLOW) {
                            Thread.yield();
                            continue;
                        } else if (context instanceof Path p) {
                            if (p.equals(path.getFileName())) {
                                eventHandler().accept(mapper().apply(p, Report.Type.of(kind)));
                            }
                        }

                        boolean valid = key.reset();
                        if (!valid) {
                            break;
                        }
                    }

                    Thread.yield();
                }
            } finally {
                onClose();
                watcher.close();
            }

        } catch (IOException e) {
            onError().accept(e);
        }
    }
}
